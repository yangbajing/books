# 微服务架构

微服务架构是一种将应用程序定义为服务集合的架构风格。这些应用程序主要具有以下特征：

- 它们是松散耦合的，这使您能够创建高度可维护和可测试的服务。
- 每项服务都可以独立部署和扩展。
- 它们专注于业务能力的建设。
- 每项服务或服务集都可以轻松分配给专门团队来负责代码所有权。
- 不需要对技术栈进行长期承若。
- 如果其中中一个服务发生故障，其它服务仍然可以继续使用。

首先，您必须决定微服务架构是否适合您的产品架构。如前所述，从单体架构开始是一种最佳实践，因为它使您能够理解您的业务能力。一旦您开始遇到可扩展性问题、开发效率低下或发布周期较长，您可以重新评估您的环境，以查看功能分解是否适合您的应用程序。一旦您决定使用微服务架构，您可能会拥有独立可扩展的服务、在开发过程中仅包含特定上下文的小项目，以及由于更快的测试验证和小型发布工件而实现的更快部署。

## 处理数据一致性

保持数据一致性对几乎任何类型的应用程序都是至关重要的。在单体架构中，数据一致性通常通过事务来确保。事务是一系列应成功完成的操作；如果其中任何一个操作失败，所有操作将自动回滚。为了保持数据一致性，事务首先开始，执行实际业务逻辑，然后在成功的情况下提交事务，或在失败的情况下回滚事务。举个例子，假设一旦执行 `Order :create()` 方法，它会调用一系列操作，例如 `Payment:create()` 和 `Shipping:start()` 。如果 `Payment` 和 `Shipping` 操作都成功，它将成功提交 `Order` 状态为 `SUCCESS` 。同样，如果 `Shipping` 操作失败，它将回滚 `Payment` 操作，并将 `Order` 操作标记为 `FAILED` （见图 2.2）。

TODO 补充图示

一个典型的事务可以用开始和提交/回滚这两个步骤来表示，在此期间，您开始一个事务并执行实际操作；然后，您可能会将数据提交到数据存储中或回滚整个操作。现在我们明白在单体架构中数据一致性可以很容易地处理，让我们看看在微服务架构中是如何处理的。

## Saga 模式

事务是应用程序中维护数据一致性的关键部分。在单体应用中，数据源位于同一应用程序中，但一旦切换到微服务架构，数据状态就分散在各个服务中。每个服务都有自己的数据存储，这意味着单个事务无法处理数据的一致性。要在分布式系统中实现数据一致性，您有两个选择：两阶段提交（2PC）和补偿事务（saga）。2PC 协调形成分布式原子事务的所有过程，并确定它们是应该提交还是中止。补偿事务是一系列本地事务，更新每个服务并发布另一个消息以触发下一个服务上的另一个本地事务。

由于事务步骤跨越多个服务，因此无法通过注释或两行代码来处理。然而，已经有广泛使用的 saga 实践，因此您无需为您的用例重新发明轮子。基于编排和协调者的 saga 是服务间通信中最流行的模式，以确保数据的一致性。

## 基于编排（Choreography）的 Saga

基于编排的长事务是一种模式，其中每个服务执行其本地事务并发布事件以触发下一个服务执行其本地事务。每当创建一个长篇故事时，可以通过以下模式完成：

- 服务在事务完成后将结果返回给客户端。它接收一个事件以更新其领域对象，并发布成功或失败状态。
- 一个事务被创建，客户端开始轮询下一个服务以获取成功或失败的响应。启动轮询的唯一标识符应在事务创建时直接返回。
- 一个事务被创建，客户端使用长链接协议（如：WebSocket）连接，服务通过 WebSocket 协议将结果发送回去。一旦返回成功或失败的结果，则事务完成。

现在让我们看看如何将这些符号之一应用于订单创建流程的实际用例。

在典型的订单创建流程中，一个 saga 在 Order Service 中创建， `Order` 以 `PENDING` 状态创建。它在 `Order` 被持久化并被 Payment Service 消费后，发送一个名为 `ORDER_CREATED` 的事件，Payment Service 将尝试向客户收费并发送另一个事件： `PAYMENT_CREATED` 或 `PAYMENT_FAILED` 。如果失败， Order Service 将被通知， Order 将被标记为 `FAILED` 。如果成功， Shipping Service 将消费该事件并启动发货流程。最后，它将为失败或成功创建另一个事件，这将导致 Order 的状态被标记为 `FAILED` 或 `SUCCESS` 。图 2.3 显示了与基于编排的 saga 的通信的高级图示。

TODO 补充图示

服务通信通过队列可以通过两种方式处理：

1. 命令通道（Command Channel）：发布者直接向下一个服务发送一条消息，带有一个 replyToChannel 参数，以便在完成操作并提交事务后通知消费者。该模式的主要缺点是发布者需要知道下一个服务的位置。
2. 发布/订阅（Pub/Sub）：发布者发布一个领域事件，感兴趣的消费者可以消费消息以处理并提交本地事务。该表示法的主要缺点是可能存在单点故障，因为所有订阅者使用一个代理技术，所有事件都发送给消费者。

让我们看看如何使用命令通道表示法：需要额外信息的异步通信，以决定下一步该做什么。除了构成实际数据的字段外，还注入了一个特定字段，称为 replyTo 通道，以便消费者服务可以将结果发送回该通道。将一些关联 ID 添加到这些事件中也是最佳实践，以便查看特定事件系列的整体情况，如图 2.4 所示

TODO 补充图示

这种通信在另一种微服务通信模式中被广泛使用，称为基于协调的长事务。让我们来看看这种模式，以了解在微服务架构中如何保证数据一致性。

## 基于协调（Orchestrator）的 Saga

让我们重新设计订单服务的创建流程，以使用基于协调的 saga 模式创建一个订单 saga。基于协调的 saga 由一个协调者和参与者组成，协调者告诉参与者该做什么。协调者可以使用命令通道或请求/响应方式与参与者进行通信。它单独连接参与者，告诉他们执行本地事务，并根据该响应决定下一步。

每当您向订单服务发送创建订单请求时，它会启动一个负责执行一系列步骤以完成操作的事务。当它调用支付服务向客户收取特定订单的费用时，它可以返回成功或失败。如果返回成功，创建订单事务将继续进行下一步，在我们的案例中是发货。如果在支付服务中失败，事务将执行补偿交易以撤销操作，这一步是退款。如果创建订单事务成功执行所有步骤，订单状态将被保存为成功。请记住，如果事务在任何特定步骤失败，它将从底部向上执行补偿交易。例如，如果在发货时失败，它将执行 `Payment:refund()` 和 `Order:cancel()` ，例如订单创建的回滚操作，如图 2.5 所示。

TODO 补充图示

我们将使用请求/响应的方式来完成跨服务通信的事务流。每个服务都应该知道所有其他服务的地址以便连接。让我们更仔细地看看服务在微服务架构中如何相互发现。
